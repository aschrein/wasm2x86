//
//////////////////////////////
// This ISPC kernel is autogenerated by spirv-cross.
// Wed Mar 25 08:08:04 2020
//////////////////////////////
//

#include "spirvcross_stdlib.ispc"

//////////////////////////////
// Work Group
//////////////////////////////
static uniform int3 gl_WorkGroupSize = {512, 512, 1};


//////////////////////////////
// Resources
//////////////////////////////
struct inputs
{
    float2 iResolution;
    float2 offset;
    float2 mouse;
    float iTime;
    float iFrame;
};


struct outputs
{
    int imageData[];
};



//////////////////////////////
// Shader Code
//////////////////////////////
static SPIRV_INLINE uniform mat3 rotationMatrix(uniform float3& axis, uniform float& angle)
{
    axis = normalize(axis);
    uniform float s = sin(angle);
    uniform float c = cos(angle);
    uniform float oc = 1.0f - c;
    uniform float _58 = axis.x;
    uniform float _61 = axis.x;
    uniform float _67 = axis.x;
    uniform float _71 = axis.y;
    uniform float _75 = axis.z;
    uniform float _81 = axis.z;
    uniform float _84 = axis.x;
    uniform float _87 = axis.y;
    uniform float _93 = axis.x;
    uniform float _96 = axis.y;
    uniform float _99 = axis.z;
    uniform float _105 = axis.y;
    uniform float _108 = axis.y;
    uniform float _114 = axis.y;
    uniform float _117 = axis.z;
    uniform float _120 = axis.x;
    uniform float _126 = axis.z;
    uniform float _129 = axis.x;
    uniform float _132 = axis.y;
    uniform float _138 = axis.y;
    uniform float _141 = axis.z;
    uniform float _144 = axis.x;
    uniform float _150 = axis.z;
    uniform float _153 = axis.z;
    return mat3(float3(((oc * _58) * _61) + c, ((oc * _67) * _71) - (_75 * s), ((oc * _81) * _84) + (_87 * s)), float3(((oc * _93) * _96) + (_99 * s), ((oc * _105) * _108) + c, ((oc * _114) * _117) - (_120 * s)), float3(((oc * _126) * _129) - (_132 * s), ((oc * _138) * _141) + (_144 * s), ((oc * _150) * _153) + c));
}

static SPIRV_INLINE varying float mandelbox_dist(varying float3& pos)
{
    varying float4 p = float4(pos.x, pos.y, pos.z, 1.0f);
    varying float4 p0 = p;
    uniform float minRad2 = 0.25f;
    uniform float4 scale = float4(2.0f) / float4(minRad2);
    uniform float absScalem1 = 1.0f;
    uniform float AbsScaleRaisedTo1mIters = 1.9073486328125e-06f;
    for (uniform int i = 0; i < 20; i++)
    {
        varying float3 _348 = (clamp(float3(p.x, p.y, p.z), float3(-1.0f), float3(1.0f)) * 2.0f) - float3(p.x, p.y, p.z);
        p = float4(_348.x, _348.y, _348.z, p.w);
        varying float r2 = dot(float3(p.x, p.y, p.z), float3(p.x, p.y, p.z));
        p = p * clamp(max(minRad2 / r2, minRad2), 0.0f, 1.0f);
        p = (p * scale) + p0;
    }
    varying float _380 = p.w;
    return ((length(float3(p.x, p.y, p.z)) - absScalem1) / _380) - AbsScaleRaisedTo1mIters;
}

static SPIRV_INLINE varying float scene(varying float3& p)
{
    varying float3 param = p;
    return max(length(p) - 7.5f, mandelbox_dist(param));
}

static SPIRV_INLINE varying float3 normal(varying float3& p, varying float& d)
{
    uniform float e = 0.004999999888241291046142578125f;
    varying float3 param = float3(e, 0.0f, 0.0f) + p;
    varying float dx = scene(param) - d;
    varying float3 param_1 = float3(0.0f, e, 0.0f) + p;
    varying float dy = scene(param_1) - d;
    varying float3 param_2 = float3(0.0f, 0.0f, e) + p;
    varying float dz = scene(param_2) - d;
    return normalize(float3(dx, dy, dz));
}

static SPIRV_INLINE varying float3 shadeBg(varying float3& nml, varying float2& fragCoord, uniform struct inputs& v_167)
{
    uniform float _172 = v_167.iResolution.x;
    uniform float _174 = v_167.iResolution.y;
    uniform float2 aspect = float2(_172 / _174, 1.0f);
    uniform float2 _183 = v_167.iResolution;
    varying float2 uv = (((fragCoord * 2.0f) / _183) - float2(1.0f)) * aspect;
    uniform float t = 16.0f;
    uniform float3 bgLight = normalize(float3(cos((t * 0.20000000298023223876953125f) / 0.954929649829864501953125f) * 4.0f, (sin(t / 1.19366204738616943359375f) * 3.0f) - 4.0f, sin((t * 0.20000000298023223876953125f) / 0.954929649829864501953125f) * 8.0f));
    uniform float3 sun = float3(1.5f, 1.125f, 0.75f);
    varying float bgDiff = dot(nml, float3(0.0f, -1.0f, 0.0f));
    varying float sunPow = dot(nml, bgLight);
    varying float sp = max(sunPow, 0.0f);
    varying float3 bgCol = float3(0.4000000059604644775390625f, 0.699999988079071044921875f, 0.64999997615814208984375f) * (max(0.0f, bgDiff) * 2.0f);
    bgCol = bgCol + (float3(0.4000000059604644775390625f, 0.550000011920928955078125f, 0.89999997615814208984375f) * max(0.0f, -bgDiff));
    bgCol = bgCol + (float3(0.20000000298023223876953125f, 0.5f, 0.699999988079071044921875f) * ((0.5f * pow(1.0f - abs(bgDiff), 5.0f)) * (5.0f - dot(uv, uv))));
    bgCol = bgCol + (sun * ((0.5f * pow(sp, 3.0f)) + pow(sp, 256.0f)));
    uniform float _283 = bgLight.y;
    bgCol = bgCol + (float3(0.5f, 0.20000000298023223876953125f, 0.1500000059604644775390625f) * (pow(sp, 8.0f) + pow(sp, abs(_283) * 128.0f)));
    bgCol = bgCol + (float3(1.89999997615814208984375f, 0.800000011920928955078125f, 0.89999997615814208984375f) * ((1.0f - pow(abs(bgDiff), 0.60000002384185791015625f)) * 0.5f));
    return pow(max(float3(0.0f), bgCol), float3(1.89999997615814208984375f));
}

// static SPIRV_INLINE varying float3 step_inner(float3 &ro, float3 &rd, float &t)
// {
//     varying float3 param_3 = ro;
//     varying float param_4 = t;
//     varying float3 nml = normal(param_3, param_4);
//     rd = normalize(reflect(rd, nml));
//     ro = ro + (rd * 0.004999999888241291046142578125f);
// }

static SPIRV_INLINE void step(float3 &ro, float3 &rd, float3 &transmit, float &bounce) {
    for (varying int i = 0; i < 70; i++)
            {
                bounce = 0.0f;
                varying float3 param_2 = ro;
                varying float t = scene(param_2);
                if (t < 0.00124999997206032276153564453125f)
                {
                    varying float3 param_3 = ro;
                    varying float param_4 = t;
                    varying float3 nml = normal(param_3, param_4);
                    rd = normalize(reflect(rd, nml));
                    ro = ro + (rd * 0.004999999888241291046142578125f);
                    transmit = transmit * (float3(0.52499997615814208984375f, 0.560000002384185791015625f, 0.62999999523162841796875f) - float3(float_cast(i) / 70.0f));
                    bounce = 1.0f;
                    break;
                }
                else
                {
                    if (t > 17.0f)
                    {
                        break;
                    }
                    else
                    {
                        ro = ro + (rd * t);
                    }
                }
            }
}

static SPIRV_INLINE void mainImage(varying float4& fragColor, varying float2& fragCoord, uniform struct inputs& v_167)
{
    fragColor = float4(0.0f);
    for (uniform float x = 0.0f; x < 2.0f; x += 1.0f)
    {
        for (uniform float y = 0.0f; y < 2.0f; y += 1.0f)
        {
            uniform float2 _458 = v_167.iResolution;
            varying float2 uv = (float2(x / 2.0f, y / 2.0f) + fragCoord) / _458;
            uv = (float2(0.5f) - uv) * 2.0f;
            uniform float _465 = v_167.iResolution.x;
            uniform float _467 = v_167.iResolution.y;
            varying float _470 = uv.x;
            uv.x = _470 * (_465 / _467);
            uniform float time = 22.8999996185302734375f;
            uniform float a = cos((time / 3.5342299938201904296875f) * 0.5f);
            uniform float ca = cos(a);
            uniform float sa = sin(a);
            uv = uv * mat2(float2(ca, sa), float2(-sa, ca));
            uniform float3 param = float3(0.8164966106414794921875f, -0.40824830532073974609375f, 0.40824830532073974609375f);
            uniform float param_1 = time * 0.0500000007450580596923828125f;
            uniform mat3 _509 = rotationMatrix(param, param_1);
            uniform mat3 rot = _509;
            varying float3 ro = rot * float3(0.0f, 0.0f, -15.0f);
            varying float3 rd = rot * normalize(float3(uv.x, uv.y, 5.5f));
            ro = ro + (rd * 4.0f);
            varying float3 transmit = float3(1.0f);
            varying float bounce;
            step(ro, rd, transmit, bounce);
            transmit = transmit * bounce;
            varying float3 param_5 = float3(0.0f) - rd;
            varying float2 param_6 = fragCoord;
            varying float3 _607 = float3(1.0f) - exp((transmit * (-1.60000002384185791015625f)) * shadeBg(param_5, param_6, v_167));
            fragColor = fragColor + float4(_607.x, _607.y, _607.z, 1.0f);
        }
    }
    fragColor = fragColor / float4(4.0f);
}

static SPIRV_INLINE void program_ispc_main(uniform int3 gl_NumWorkGroups, uniform int3 gl_WorkGroupID,
varying int3 gl_LocalInvocationID, varying int3 gl_GlobalInvocationID, varying int gl_LocalInvocationIndex,
uniform struct inputs v_167_ptr[], uniform int _682[])
{
    uniform struct inputs v_167 = v_167_ptr[0];
    uniform float _623 = v_167.iResolution.x;
    uniform int width = int_cast(_623);
    uniform float _627 = v_167.iResolution.y;
    uniform int height = int_cast(_627);
    uniform float2 _638 = v_167.offset;
    varying float2 fragCoord = float2(int2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)) + _638;
    uniform float _641 = v_167.iResolution.y;
    varying float _643 = fragCoord.y;
    fragCoord.y = _641 - _643;
    varying float2 param_1 = fragCoord;
    varying float4 param;
    mainImage(param, param_1, v_167);
    varying float4 fragColor = param;
    uniform int _657 = gl_NumWorkGroups.x;
    uniform int tileWidth = _657 * 512u;
    varying int _663 = gl_GlobalInvocationID.y;
    varying int _666 = gl_GlobalInvocationID.x;
    varying int pxoff = (tileWidth * _663) + _666;
    fragColor = max(float4(0.0f), min(float4(1.0f), fragColor)) * 255.0f;
    varying int3 rgb = int3(float3(fragColor.x, fragColor.y, fragColor.z));
    varying int _686 = rgb.z;
    varying int _691 = rgb.y;
    varying int _696 = rgb.x;
    // print("%, ", param.x);
    _682[pxoff] = ((4278190080u | (_686 << (int)(16))) | (_691 << (int)(8))) | _696;
}


//////////////////////////////
// ISPC Entry Points
//////////////////////////////
